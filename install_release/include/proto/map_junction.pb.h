// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/map_junction.proto

#ifndef PROTOBUF_proto_2fmap_5fjunction_2eproto__INCLUDED
#define PROTOBUF_proto_2fmap_5fjunction_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/map_id.pb.h"
#include "proto/map_geometry.pb.h"
// @@protoc_insertion_point(includes)

namespace trunk {
namespace hadmap {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fmap_5fjunction_2eproto();
void protobuf_AssignDesc_proto_2fmap_5fjunction_2eproto();
void protobuf_ShutdownFile_proto_2fmap_5fjunction_2eproto();

class LaneLink;
class Connection;
class Junction;

// ===================================================================

class LaneLink : public ::google::protobuf::Message {
 public:
  LaneLink();
  virtual ~LaneLink();

  LaneLink(const LaneLink& from);

  inline LaneLink& operator=(const LaneLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneLink& default_instance();

  void Swap(LaneLink* other);

  // implements Message ----------------------------------------------

  LaneLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaneLink& from);
  void MergeFrom(const LaneLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .trunk.hadmap.Id from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::trunk::hadmap::Id& from() const;
  inline ::trunk::hadmap::Id* mutable_from();
  inline ::trunk::hadmap::Id* release_from();
  inline void set_allocated_from(::trunk::hadmap::Id* from);

  // optional .trunk.hadmap.Id to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::trunk::hadmap::Id& to() const;
  inline ::trunk::hadmap::Id* mutable_to();
  inline ::trunk::hadmap::Id* release_to();
  inline void set_allocated_to(::trunk::hadmap::Id* to);

  // @@protoc_insertion_point(class_scope:trunk.hadmap.LaneLink)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trunk::hadmap::Id* from_;
  ::trunk::hadmap::Id* to_;
  friend void  protobuf_AddDesc_proto_2fmap_5fjunction_2eproto();
  friend void protobuf_AssignDesc_proto_2fmap_5fjunction_2eproto();
  friend void protobuf_ShutdownFile_proto_2fmap_5fjunction_2eproto();

  void InitAsDefaultInstance();
  static LaneLink* default_instance_;
};
// -------------------------------------------------------------------

class Connection : public ::google::protobuf::Message {
 public:
  Connection();
  virtual ~Connection();

  Connection(const Connection& from);

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connection& default_instance();

  void Swap(Connection* other);

  // implements Message ----------------------------------------------

  Connection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .trunk.hadmap.Id id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::trunk::hadmap::Id& id() const;
  inline ::trunk::hadmap::Id* mutable_id();
  inline ::trunk::hadmap::Id* release_id();
  inline void set_allocated_id(::trunk::hadmap::Id* id);

  // optional .trunk.hadmap.Id incoming_road = 2;
  inline bool has_incoming_road() const;
  inline void clear_incoming_road();
  static const int kIncomingRoadFieldNumber = 2;
  inline const ::trunk::hadmap::Id& incoming_road() const;
  inline ::trunk::hadmap::Id* mutable_incoming_road();
  inline ::trunk::hadmap::Id* release_incoming_road();
  inline void set_allocated_incoming_road(::trunk::hadmap::Id* incoming_road);

  // optional .trunk.hadmap.Id connecting_road = 3;
  inline bool has_connecting_road() const;
  inline void clear_connecting_road();
  static const int kConnectingRoadFieldNumber = 3;
  inline const ::trunk::hadmap::Id& connecting_road() const;
  inline ::trunk::hadmap::Id* mutable_connecting_road();
  inline ::trunk::hadmap::Id* release_connecting_road();
  inline void set_allocated_connecting_road(::trunk::hadmap::Id* connecting_road);

  // repeated .trunk.hadmap.LaneLink lane_link = 4;
  inline int lane_link_size() const;
  inline void clear_lane_link();
  static const int kLaneLinkFieldNumber = 4;
  inline const ::trunk::hadmap::LaneLink& lane_link(int index) const;
  inline ::trunk::hadmap::LaneLink* mutable_lane_link(int index);
  inline ::trunk::hadmap::LaneLink* add_lane_link();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::LaneLink >&
      lane_link() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::LaneLink >*
      mutable_lane_link();

  // @@protoc_insertion_point(class_scope:trunk.hadmap.Connection)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_incoming_road();
  inline void clear_has_incoming_road();
  inline void set_has_connecting_road();
  inline void clear_has_connecting_road();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trunk::hadmap::Id* id_;
  ::trunk::hadmap::Id* incoming_road_;
  ::trunk::hadmap::Id* connecting_road_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::LaneLink > lane_link_;
  friend void  protobuf_AddDesc_proto_2fmap_5fjunction_2eproto();
  friend void protobuf_AssignDesc_proto_2fmap_5fjunction_2eproto();
  friend void protobuf_ShutdownFile_proto_2fmap_5fjunction_2eproto();

  void InitAsDefaultInstance();
  static Connection* default_instance_;
};
// -------------------------------------------------------------------

class Junction : public ::google::protobuf::Message {
 public:
  Junction();
  virtual ~Junction();

  Junction(const Junction& from);

  inline Junction& operator=(const Junction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Junction& default_instance();

  void Swap(Junction* other);

  // implements Message ----------------------------------------------

  Junction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Junction& from);
  void MergeFrom(const Junction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .trunk.hadmap.Id id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::trunk::hadmap::Id& id() const;
  inline ::trunk::hadmap::Id* mutable_id();
  inline ::trunk::hadmap::Id* release_id();
  inline void set_allocated_id(::trunk::hadmap::Id* id);

  // optional .trunk.hadmap.Polygon polygon = 2;
  inline bool has_polygon() const;
  inline void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  inline const ::trunk::hadmap::Polygon& polygon() const;
  inline ::trunk::hadmap::Polygon* mutable_polygon();
  inline ::trunk::hadmap::Polygon* release_polygon();
  inline void set_allocated_polygon(::trunk::hadmap::Polygon* polygon);

  // repeated .trunk.hadmap.Connection connection = 3;
  inline int connection_size() const;
  inline void clear_connection();
  static const int kConnectionFieldNumber = 3;
  inline const ::trunk::hadmap::Connection& connection(int index) const;
  inline ::trunk::hadmap::Connection* mutable_connection(int index);
  inline ::trunk::hadmap::Connection* add_connection();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Connection >&
      connection() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Connection >*
      mutable_connection();

  // repeated .trunk.hadmap.Id overlap_id = 4;
  inline int overlap_id_size() const;
  inline void clear_overlap_id();
  static const int kOverlapIdFieldNumber = 4;
  inline const ::trunk::hadmap::Id& overlap_id(int index) const;
  inline ::trunk::hadmap::Id* mutable_overlap_id(int index);
  inline ::trunk::hadmap::Id* add_overlap_id();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Id >&
      overlap_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Id >*
      mutable_overlap_id();

  // @@protoc_insertion_point(class_scope:trunk.hadmap.Junction)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_polygon();
  inline void clear_has_polygon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trunk::hadmap::Id* id_;
  ::trunk::hadmap::Polygon* polygon_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Connection > connection_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Id > overlap_id_;
  friend void  protobuf_AddDesc_proto_2fmap_5fjunction_2eproto();
  friend void protobuf_AssignDesc_proto_2fmap_5fjunction_2eproto();
  friend void protobuf_ShutdownFile_proto_2fmap_5fjunction_2eproto();

  void InitAsDefaultInstance();
  static Junction* default_instance_;
};
// ===================================================================


// ===================================================================

// LaneLink

// optional .trunk.hadmap.Id from = 1;
inline bool LaneLink::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneLink::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneLink::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneLink::clear_from() {
  if (from_ != NULL) from_->::trunk::hadmap::Id::Clear();
  clear_has_from();
}
inline const ::trunk::hadmap::Id& LaneLink::from() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.LaneLink.from)
  return from_ != NULL ? *from_ : *default_instance_->from_;
}
inline ::trunk::hadmap::Id* LaneLink::mutable_from() {
  set_has_from();
  if (from_ == NULL) from_ = new ::trunk::hadmap::Id;
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.LaneLink.from)
  return from_;
}
inline ::trunk::hadmap::Id* LaneLink::release_from() {
  clear_has_from();
  ::trunk::hadmap::Id* temp = from_;
  from_ = NULL;
  return temp;
}
inline void LaneLink::set_allocated_from(::trunk::hadmap::Id* from) {
  delete from_;
  from_ = from;
  if (from) {
    set_has_from();
  } else {
    clear_has_from();
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.LaneLink.from)
}

// optional .trunk.hadmap.Id to = 2;
inline bool LaneLink::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneLink::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneLink::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneLink::clear_to() {
  if (to_ != NULL) to_->::trunk::hadmap::Id::Clear();
  clear_has_to();
}
inline const ::trunk::hadmap::Id& LaneLink::to() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.LaneLink.to)
  return to_ != NULL ? *to_ : *default_instance_->to_;
}
inline ::trunk::hadmap::Id* LaneLink::mutable_to() {
  set_has_to();
  if (to_ == NULL) to_ = new ::trunk::hadmap::Id;
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.LaneLink.to)
  return to_;
}
inline ::trunk::hadmap::Id* LaneLink::release_to() {
  clear_has_to();
  ::trunk::hadmap::Id* temp = to_;
  to_ = NULL;
  return temp;
}
inline void LaneLink::set_allocated_to(::trunk::hadmap::Id* to) {
  delete to_;
  to_ = to;
  if (to) {
    set_has_to();
  } else {
    clear_has_to();
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.LaneLink.to)
}

// -------------------------------------------------------------------

// Connection

// optional .trunk.hadmap.Id id = 1;
inline bool Connection::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Connection::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Connection::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Connection::clear_id() {
  if (id_ != NULL) id_->::trunk::hadmap::Id::Clear();
  clear_has_id();
}
inline const ::trunk::hadmap::Id& Connection::id() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Connection.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::trunk::hadmap::Id* Connection::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::trunk::hadmap::Id;
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Connection.id)
  return id_;
}
inline ::trunk::hadmap::Id* Connection::release_id() {
  clear_has_id();
  ::trunk::hadmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Connection::set_allocated_id(::trunk::hadmap::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Connection.id)
}

// optional .trunk.hadmap.Id incoming_road = 2;
inline bool Connection::has_incoming_road() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Connection::set_has_incoming_road() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Connection::clear_has_incoming_road() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Connection::clear_incoming_road() {
  if (incoming_road_ != NULL) incoming_road_->::trunk::hadmap::Id::Clear();
  clear_has_incoming_road();
}
inline const ::trunk::hadmap::Id& Connection::incoming_road() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Connection.incoming_road)
  return incoming_road_ != NULL ? *incoming_road_ : *default_instance_->incoming_road_;
}
inline ::trunk::hadmap::Id* Connection::mutable_incoming_road() {
  set_has_incoming_road();
  if (incoming_road_ == NULL) incoming_road_ = new ::trunk::hadmap::Id;
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Connection.incoming_road)
  return incoming_road_;
}
inline ::trunk::hadmap::Id* Connection::release_incoming_road() {
  clear_has_incoming_road();
  ::trunk::hadmap::Id* temp = incoming_road_;
  incoming_road_ = NULL;
  return temp;
}
inline void Connection::set_allocated_incoming_road(::trunk::hadmap::Id* incoming_road) {
  delete incoming_road_;
  incoming_road_ = incoming_road;
  if (incoming_road) {
    set_has_incoming_road();
  } else {
    clear_has_incoming_road();
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Connection.incoming_road)
}

// optional .trunk.hadmap.Id connecting_road = 3;
inline bool Connection::has_connecting_road() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Connection::set_has_connecting_road() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Connection::clear_has_connecting_road() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Connection::clear_connecting_road() {
  if (connecting_road_ != NULL) connecting_road_->::trunk::hadmap::Id::Clear();
  clear_has_connecting_road();
}
inline const ::trunk::hadmap::Id& Connection::connecting_road() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Connection.connecting_road)
  return connecting_road_ != NULL ? *connecting_road_ : *default_instance_->connecting_road_;
}
inline ::trunk::hadmap::Id* Connection::mutable_connecting_road() {
  set_has_connecting_road();
  if (connecting_road_ == NULL) connecting_road_ = new ::trunk::hadmap::Id;
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Connection.connecting_road)
  return connecting_road_;
}
inline ::trunk::hadmap::Id* Connection::release_connecting_road() {
  clear_has_connecting_road();
  ::trunk::hadmap::Id* temp = connecting_road_;
  connecting_road_ = NULL;
  return temp;
}
inline void Connection::set_allocated_connecting_road(::trunk::hadmap::Id* connecting_road) {
  delete connecting_road_;
  connecting_road_ = connecting_road;
  if (connecting_road) {
    set_has_connecting_road();
  } else {
    clear_has_connecting_road();
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Connection.connecting_road)
}

// repeated .trunk.hadmap.LaneLink lane_link = 4;
inline int Connection::lane_link_size() const {
  return lane_link_.size();
}
inline void Connection::clear_lane_link() {
  lane_link_.Clear();
}
inline const ::trunk::hadmap::LaneLink& Connection::lane_link(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Connection.lane_link)
  return lane_link_.Get(index);
}
inline ::trunk::hadmap::LaneLink* Connection::mutable_lane_link(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Connection.lane_link)
  return lane_link_.Mutable(index);
}
inline ::trunk::hadmap::LaneLink* Connection::add_lane_link() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Connection.lane_link)
  return lane_link_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::LaneLink >&
Connection::lane_link() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Connection.lane_link)
  return lane_link_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::LaneLink >*
Connection::mutable_lane_link() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Connection.lane_link)
  return &lane_link_;
}

// -------------------------------------------------------------------

// Junction

// optional .trunk.hadmap.Id id = 1;
inline bool Junction::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Junction::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Junction::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Junction::clear_id() {
  if (id_ != NULL) id_->::trunk::hadmap::Id::Clear();
  clear_has_id();
}
inline const ::trunk::hadmap::Id& Junction::id() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Junction.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::trunk::hadmap::Id* Junction::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::trunk::hadmap::Id;
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Junction.id)
  return id_;
}
inline ::trunk::hadmap::Id* Junction::release_id() {
  clear_has_id();
  ::trunk::hadmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Junction::set_allocated_id(::trunk::hadmap::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Junction.id)
}

// optional .trunk.hadmap.Polygon polygon = 2;
inline bool Junction::has_polygon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Junction::set_has_polygon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Junction::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Junction::clear_polygon() {
  if (polygon_ != NULL) polygon_->::trunk::hadmap::Polygon::Clear();
  clear_has_polygon();
}
inline const ::trunk::hadmap::Polygon& Junction::polygon() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Junction.polygon)
  return polygon_ != NULL ? *polygon_ : *default_instance_->polygon_;
}
inline ::trunk::hadmap::Polygon* Junction::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) polygon_ = new ::trunk::hadmap::Polygon;
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Junction.polygon)
  return polygon_;
}
inline ::trunk::hadmap::Polygon* Junction::release_polygon() {
  clear_has_polygon();
  ::trunk::hadmap::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void Junction::set_allocated_polygon(::trunk::hadmap::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Junction.polygon)
}

// repeated .trunk.hadmap.Connection connection = 3;
inline int Junction::connection_size() const {
  return connection_.size();
}
inline void Junction::clear_connection() {
  connection_.Clear();
}
inline const ::trunk::hadmap::Connection& Junction::connection(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Junction.connection)
  return connection_.Get(index);
}
inline ::trunk::hadmap::Connection* Junction::mutable_connection(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Junction.connection)
  return connection_.Mutable(index);
}
inline ::trunk::hadmap::Connection* Junction::add_connection() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Junction.connection)
  return connection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Connection >&
Junction::connection() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Junction.connection)
  return connection_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Connection >*
Junction::mutable_connection() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Junction.connection)
  return &connection_;
}

// repeated .trunk.hadmap.Id overlap_id = 4;
inline int Junction::overlap_id_size() const {
  return overlap_id_.size();
}
inline void Junction::clear_overlap_id() {
  overlap_id_.Clear();
}
inline const ::trunk::hadmap::Id& Junction::overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Junction.overlap_id)
  return overlap_id_.Get(index);
}
inline ::trunk::hadmap::Id* Junction::mutable_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Junction.overlap_id)
  return overlap_id_.Mutable(index);
}
inline ::trunk::hadmap::Id* Junction::add_overlap_id() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Junction.overlap_id)
  return overlap_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Id >&
Junction::overlap_id() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Junction.overlap_id)
  return overlap_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Id >*
Junction::mutable_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Junction.overlap_id)
  return &overlap_id_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace hadmap
}  // namespace trunk

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fmap_5fjunction_2eproto__INCLUDED
