// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/map.proto

#ifndef PROTOBUF_proto_2fmap_2eproto__INCLUDED
#define PROTOBUF_proto_2fmap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/map_crosswalk.pb.h"
#include "proto/map_junction.pb.h"
#include "proto/map_lane.pb.h"
#include "proto/map_overlap.pb.h"
#include "proto/map_signal.pb.h"
#include "proto/map_road.pb.h"
#include "proto/map_roadmarker.pb.h"
// @@protoc_insertion_point(includes)

namespace trunk {
namespace hadmap {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fmap_2eproto();
void protobuf_AssignDesc_proto_2fmap_2eproto();
void protobuf_ShutdownFile_proto_2fmap_2eproto();

class Header;
class Map;

// ===================================================================

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const void* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional bytes date = 2;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 2;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const void* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes rev_major = 4;
  inline bool has_rev_major() const;
  inline void clear_rev_major();
  static const int kRevMajorFieldNumber = 4;
  inline const ::std::string& rev_major() const;
  inline void set_rev_major(const ::std::string& value);
  inline void set_rev_major(const char* value);
  inline void set_rev_major(const void* value, size_t size);
  inline ::std::string* mutable_rev_major();
  inline ::std::string* release_rev_major();
  inline void set_allocated_rev_major(::std::string* rev_major);

  // optional bytes rev_minor = 5;
  inline bool has_rev_minor() const;
  inline void clear_rev_minor();
  static const int kRevMinorFieldNumber = 5;
  inline const ::std::string& rev_minor() const;
  inline void set_rev_minor(const ::std::string& value);
  inline void set_rev_minor(const char* value);
  inline void set_rev_minor(const void* value, size_t size);
  inline ::std::string* mutable_rev_minor();
  inline ::std::string* release_rev_minor();
  inline void set_allocated_rev_minor(::std::string* rev_minor);

  // optional double left = 6;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 6;
  inline double left() const;
  inline void set_left(double value);

  // optional double top = 7;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 7;
  inline double top() const;
  inline void set_top(double value);

  // optional double right = 8;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 8;
  inline double right() const;
  inline void set_right(double value);

  // optional double bottom = 9;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 9;
  inline double bottom() const;
  inline void set_bottom(double value);

  // optional bytes vendor = 10;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 10;
  inline const ::std::string& vendor() const;
  inline void set_vendor(const ::std::string& value);
  inline void set_vendor(const char* value);
  inline void set_vendor(const void* value, size_t size);
  inline ::std::string* mutable_vendor();
  inline ::std::string* release_vendor();
  inline void set_allocated_vendor(::std::string* vendor);

  // @@protoc_insertion_point(class_scope:trunk.hadmap.Header)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rev_major();
  inline void clear_has_rev_major();
  inline void set_has_rev_minor();
  inline void clear_has_rev_minor();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_vendor();
  inline void clear_has_vendor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* version_;
  ::std::string* date_;
  ::std::string* name_;
  ::std::string* rev_major_;
  ::std::string* rev_minor_;
  double left_;
  double top_;
  double right_;
  double bottom_;
  ::std::string* vendor_;
  friend void  protobuf_AddDesc_proto_2fmap_2eproto();
  friend void protobuf_AssignDesc_proto_2fmap_2eproto();
  friend void protobuf_ShutdownFile_proto_2fmap_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  void Swap(Map* other);

  // implements Message ----------------------------------------------

  Map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .trunk.hadmap.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::trunk::hadmap::Header& header() const;
  inline ::trunk::hadmap::Header* mutable_header();
  inline ::trunk::hadmap::Header* release_header();
  inline void set_allocated_header(::trunk::hadmap::Header* header);

  // repeated .trunk.hadmap.Lane lane = 2;
  inline int lane_size() const;
  inline void clear_lane();
  static const int kLaneFieldNumber = 2;
  inline const ::trunk::hadmap::Lane& lane(int index) const;
  inline ::trunk::hadmap::Lane* mutable_lane(int index);
  inline ::trunk::hadmap::Lane* add_lane();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Lane >&
      lane() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Lane >*
      mutable_lane();

  // repeated .trunk.hadmap.Road road = 3;
  inline int road_size() const;
  inline void clear_road();
  static const int kRoadFieldNumber = 3;
  inline const ::trunk::hadmap::Road& road(int index) const;
  inline ::trunk::hadmap::Road* mutable_road(int index);
  inline ::trunk::hadmap::Road* add_road();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Road >&
      road() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Road >*
      mutable_road();

  // repeated .trunk.hadmap.Crosswalk crosswalk = 4;
  inline int crosswalk_size() const;
  inline void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 4;
  inline const ::trunk::hadmap::Crosswalk& crosswalk(int index) const;
  inline ::trunk::hadmap::Crosswalk* mutable_crosswalk(int index);
  inline ::trunk::hadmap::Crosswalk* add_crosswalk();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Crosswalk >&
      crosswalk() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Crosswalk >*
      mutable_crosswalk();

  // repeated .trunk.hadmap.Junction junction = 5;
  inline int junction_size() const;
  inline void clear_junction();
  static const int kJunctionFieldNumber = 5;
  inline const ::trunk::hadmap::Junction& junction(int index) const;
  inline ::trunk::hadmap::Junction* mutable_junction(int index);
  inline ::trunk::hadmap::Junction* add_junction();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Junction >&
      junction() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Junction >*
      mutable_junction();

  // repeated .trunk.hadmap.Signal signal = 6;
  inline int signal_size() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 6;
  inline const ::trunk::hadmap::Signal& signal(int index) const;
  inline ::trunk::hadmap::Signal* mutable_signal(int index);
  inline ::trunk::hadmap::Signal* add_signal();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Signal >&
      signal() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Signal >*
      mutable_signal();

  // repeated .trunk.hadmap.Overlap overlap = 7;
  inline int overlap_size() const;
  inline void clear_overlap();
  static const int kOverlapFieldNumber = 7;
  inline const ::trunk::hadmap::Overlap& overlap(int index) const;
  inline ::trunk::hadmap::Overlap* mutable_overlap(int index);
  inline ::trunk::hadmap::Overlap* add_overlap();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Overlap >&
      overlap() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Overlap >*
      mutable_overlap();

  // repeated .trunk.hadmap.RoadMarker roadmarker = 8;
  inline int roadmarker_size() const;
  inline void clear_roadmarker();
  static const int kRoadmarkerFieldNumber = 8;
  inline const ::trunk::hadmap::RoadMarker& roadmarker(int index) const;
  inline ::trunk::hadmap::RoadMarker* mutable_roadmarker(int index);
  inline ::trunk::hadmap::RoadMarker* add_roadmarker();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::RoadMarker >&
      roadmarker() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::RoadMarker >*
      mutable_roadmarker();

  // @@protoc_insertion_point(class_scope:trunk.hadmap.Map)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trunk::hadmap::Header* header_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Lane > lane_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Road > road_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Crosswalk > crosswalk_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Junction > junction_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Signal > signal_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Overlap > overlap_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::RoadMarker > roadmarker_;
  friend void  protobuf_AddDesc_proto_2fmap_2eproto();
  friend void protobuf_AssignDesc_proto_2fmap_2eproto();
  friend void protobuf_ShutdownFile_proto_2fmap_2eproto();

  void InitAsDefaultInstance();
  static Map* default_instance_;
};
// ===================================================================


// ===================================================================

// Header

// optional bytes version = 1;
inline bool Header::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Header::version() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.version)
  return *version_;
}
inline void Header::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.version)
}
inline void Header::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Header.version)
}
inline void Header::set_version(const void* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Header.version)
}
inline ::std::string* Header::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Header.version)
  return version_;
}
inline ::std::string* Header::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Header.version)
}

// optional bytes date = 2;
inline bool Header::has_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_date() {
  if (date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& Header::date() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.date)
  return *date_;
}
inline void Header::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  date_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.date)
}
inline void Header::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  date_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Header.date)
}
inline void Header::set_date(const void* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Header.date)
}
inline ::std::string* Header::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Header.date)
  return date_;
}
inline ::std::string* Header::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Header.date)
}

// optional bytes name = 3;
inline bool Header::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Header::name() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.name)
  return *name_;
}
inline void Header::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.name)
}
inline void Header::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Header.name)
}
inline void Header::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Header.name)
}
inline ::std::string* Header::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Header.name)
  return name_;
}
inline ::std::string* Header::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Header.name)
}

// optional bytes rev_major = 4;
inline bool Header::has_rev_major() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_rev_major() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_rev_major() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_rev_major() {
  if (rev_major_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_major_->clear();
  }
  clear_has_rev_major();
}
inline const ::std::string& Header::rev_major() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.rev_major)
  return *rev_major_;
}
inline void Header::set_rev_major(const ::std::string& value) {
  set_has_rev_major();
  if (rev_major_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_major_ = new ::std::string;
  }
  rev_major_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.rev_major)
}
inline void Header::set_rev_major(const char* value) {
  set_has_rev_major();
  if (rev_major_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_major_ = new ::std::string;
  }
  rev_major_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Header.rev_major)
}
inline void Header::set_rev_major(const void* value, size_t size) {
  set_has_rev_major();
  if (rev_major_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_major_ = new ::std::string;
  }
  rev_major_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Header.rev_major)
}
inline ::std::string* Header::mutable_rev_major() {
  set_has_rev_major();
  if (rev_major_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_major_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Header.rev_major)
  return rev_major_;
}
inline ::std::string* Header::release_rev_major() {
  clear_has_rev_major();
  if (rev_major_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rev_major_;
    rev_major_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_rev_major(::std::string* rev_major) {
  if (rev_major_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rev_major_;
  }
  if (rev_major) {
    set_has_rev_major();
    rev_major_ = rev_major;
  } else {
    clear_has_rev_major();
    rev_major_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Header.rev_major)
}

// optional bytes rev_minor = 5;
inline bool Header::has_rev_minor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_rev_minor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_rev_minor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_rev_minor() {
  if (rev_minor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_minor_->clear();
  }
  clear_has_rev_minor();
}
inline const ::std::string& Header::rev_minor() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.rev_minor)
  return *rev_minor_;
}
inline void Header::set_rev_minor(const ::std::string& value) {
  set_has_rev_minor();
  if (rev_minor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_minor_ = new ::std::string;
  }
  rev_minor_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.rev_minor)
}
inline void Header::set_rev_minor(const char* value) {
  set_has_rev_minor();
  if (rev_minor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_minor_ = new ::std::string;
  }
  rev_minor_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Header.rev_minor)
}
inline void Header::set_rev_minor(const void* value, size_t size) {
  set_has_rev_minor();
  if (rev_minor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_minor_ = new ::std::string;
  }
  rev_minor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Header.rev_minor)
}
inline ::std::string* Header::mutable_rev_minor() {
  set_has_rev_minor();
  if (rev_minor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rev_minor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Header.rev_minor)
  return rev_minor_;
}
inline ::std::string* Header::release_rev_minor() {
  clear_has_rev_minor();
  if (rev_minor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rev_minor_;
    rev_minor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_rev_minor(::std::string* rev_minor) {
  if (rev_minor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rev_minor_;
  }
  if (rev_minor) {
    set_has_rev_minor();
    rev_minor_ = rev_minor;
  } else {
    clear_has_rev_minor();
    rev_minor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Header.rev_minor)
}

// optional double left = 6;
inline bool Header::has_left() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_left() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_left() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline double Header::left() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.left)
  return left_;
}
inline void Header::set_left(double value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.left)
}

// optional double top = 7;
inline bool Header::has_top() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header::set_has_top() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header::clear_has_top() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline double Header::top() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.top)
  return top_;
}
inline void Header::set_top(double value) {
  set_has_top();
  top_ = value;
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.top)
}

// optional double right = 8;
inline bool Header::has_right() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_right() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_right() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline double Header::right() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.right)
  return right_;
}
inline void Header::set_right(double value) {
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.right)
}

// optional double bottom = 9;
inline bool Header::has_bottom() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Header::set_has_bottom() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Header::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Header::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline double Header::bottom() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.bottom)
  return bottom_;
}
inline void Header::set_bottom(double value) {
  set_has_bottom();
  bottom_ = value;
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.bottom)
}

// optional bytes vendor = 10;
inline bool Header::has_vendor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Header::set_has_vendor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Header::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Header::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& Header::vendor() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Header.vendor)
  return *vendor_;
}
inline void Header::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Header.vendor)
}
inline void Header::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Header.vendor)
}
inline void Header::set_vendor(const void* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Header.vendor)
}
inline ::std::string* Header::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Header.vendor)
  return vendor_;
}
inline ::std::string* Header::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_vendor(::std::string* vendor) {
  if (vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendor_;
  }
  if (vendor) {
    set_has_vendor();
    vendor_ = vendor;
  } else {
    clear_has_vendor();
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Header.vendor)
}

// -------------------------------------------------------------------

// Map

// optional .trunk.hadmap.Header header = 1;
inline bool Map::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Map::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Map::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Map::clear_header() {
  if (header_ != NULL) header_->::trunk::hadmap::Header::Clear();
  clear_has_header();
}
inline const ::trunk::hadmap::Header& Map::header() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Map.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::trunk::hadmap::Header* Map::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::trunk::hadmap::Header;
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Map.header)
  return header_;
}
inline ::trunk::hadmap::Header* Map::release_header() {
  clear_has_header();
  ::trunk::hadmap::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Map::set_allocated_header(::trunk::hadmap::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Map.header)
}

// repeated .trunk.hadmap.Lane lane = 2;
inline int Map::lane_size() const {
  return lane_.size();
}
inline void Map::clear_lane() {
  lane_.Clear();
}
inline const ::trunk::hadmap::Lane& Map::lane(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Map.lane)
  return lane_.Get(index);
}
inline ::trunk::hadmap::Lane* Map::mutable_lane(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Map.lane)
  return lane_.Mutable(index);
}
inline ::trunk::hadmap::Lane* Map::add_lane() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Map.lane)
  return lane_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Lane >&
Map::lane() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Map.lane)
  return lane_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Lane >*
Map::mutable_lane() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Map.lane)
  return &lane_;
}

// repeated .trunk.hadmap.Road road = 3;
inline int Map::road_size() const {
  return road_.size();
}
inline void Map::clear_road() {
  road_.Clear();
}
inline const ::trunk::hadmap::Road& Map::road(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Map.road)
  return road_.Get(index);
}
inline ::trunk::hadmap::Road* Map::mutable_road(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Map.road)
  return road_.Mutable(index);
}
inline ::trunk::hadmap::Road* Map::add_road() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Map.road)
  return road_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Road >&
Map::road() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Map.road)
  return road_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Road >*
Map::mutable_road() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Map.road)
  return &road_;
}

// repeated .trunk.hadmap.Crosswalk crosswalk = 4;
inline int Map::crosswalk_size() const {
  return crosswalk_.size();
}
inline void Map::clear_crosswalk() {
  crosswalk_.Clear();
}
inline const ::trunk::hadmap::Crosswalk& Map::crosswalk(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Map.crosswalk)
  return crosswalk_.Get(index);
}
inline ::trunk::hadmap::Crosswalk* Map::mutable_crosswalk(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Map.crosswalk)
  return crosswalk_.Mutable(index);
}
inline ::trunk::hadmap::Crosswalk* Map::add_crosswalk() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Map.crosswalk)
  return crosswalk_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Crosswalk >&
Map::crosswalk() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Map.crosswalk)
  return crosswalk_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Crosswalk >*
Map::mutable_crosswalk() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Map.crosswalk)
  return &crosswalk_;
}

// repeated .trunk.hadmap.Junction junction = 5;
inline int Map::junction_size() const {
  return junction_.size();
}
inline void Map::clear_junction() {
  junction_.Clear();
}
inline const ::trunk::hadmap::Junction& Map::junction(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Map.junction)
  return junction_.Get(index);
}
inline ::trunk::hadmap::Junction* Map::mutable_junction(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Map.junction)
  return junction_.Mutable(index);
}
inline ::trunk::hadmap::Junction* Map::add_junction() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Map.junction)
  return junction_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Junction >&
Map::junction() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Map.junction)
  return junction_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Junction >*
Map::mutable_junction() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Map.junction)
  return &junction_;
}

// repeated .trunk.hadmap.Signal signal = 6;
inline int Map::signal_size() const {
  return signal_.size();
}
inline void Map::clear_signal() {
  signal_.Clear();
}
inline const ::trunk::hadmap::Signal& Map::signal(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Map.signal)
  return signal_.Get(index);
}
inline ::trunk::hadmap::Signal* Map::mutable_signal(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Map.signal)
  return signal_.Mutable(index);
}
inline ::trunk::hadmap::Signal* Map::add_signal() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Map.signal)
  return signal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Signal >&
Map::signal() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Map.signal)
  return signal_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Signal >*
Map::mutable_signal() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Map.signal)
  return &signal_;
}

// repeated .trunk.hadmap.Overlap overlap = 7;
inline int Map::overlap_size() const {
  return overlap_.size();
}
inline void Map::clear_overlap() {
  overlap_.Clear();
}
inline const ::trunk::hadmap::Overlap& Map::overlap(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Map.overlap)
  return overlap_.Get(index);
}
inline ::trunk::hadmap::Overlap* Map::mutable_overlap(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Map.overlap)
  return overlap_.Mutable(index);
}
inline ::trunk::hadmap::Overlap* Map::add_overlap() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Map.overlap)
  return overlap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Overlap >&
Map::overlap() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Map.overlap)
  return overlap_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Overlap >*
Map::mutable_overlap() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Map.overlap)
  return &overlap_;
}

// repeated .trunk.hadmap.RoadMarker roadmarker = 8;
inline int Map::roadmarker_size() const {
  return roadmarker_.size();
}
inline void Map::clear_roadmarker() {
  roadmarker_.Clear();
}
inline const ::trunk::hadmap::RoadMarker& Map::roadmarker(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Map.roadmarker)
  return roadmarker_.Get(index);
}
inline ::trunk::hadmap::RoadMarker* Map::mutable_roadmarker(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Map.roadmarker)
  return roadmarker_.Mutable(index);
}
inline ::trunk::hadmap::RoadMarker* Map::add_roadmarker() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Map.roadmarker)
  return roadmarker_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::RoadMarker >&
Map::roadmarker() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Map.roadmarker)
  return roadmarker_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::RoadMarker >*
Map::mutable_roadmarker() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Map.roadmarker)
  return &roadmarker_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace hadmap
}  // namespace trunk

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fmap_2eproto__INCLUDED
