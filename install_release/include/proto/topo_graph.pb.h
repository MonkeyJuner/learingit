// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/topo_graph.proto

#ifndef PROTOBUF_proto_2ftopo_5fgraph_2eproto__INCLUDED
#define PROTOBUF_proto_2ftopo_5fgraph_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/map_geometry.pb.h"
// @@protoc_insertion_point(includes)

namespace trunk {
namespace hadmap {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2ftopo_5fgraph_2eproto();
void protobuf_AssignDesc_proto_2ftopo_5fgraph_2eproto();
void protobuf_ShutdownFile_proto_2ftopo_5fgraph_2eproto();

class Node;
class Edge;
class Graph;

enum Edge_DirectionType {
  Edge_DirectionType_FORWARD = 0,
  Edge_DirectionType_LEFT = 1,
  Edge_DirectionType_RIGHT = 2
};
bool Edge_DirectionType_IsValid(int value);
const Edge_DirectionType Edge_DirectionType_DirectionType_MIN = Edge_DirectionType_FORWARD;
const Edge_DirectionType Edge_DirectionType_DirectionType_MAX = Edge_DirectionType_RIGHT;
const int Edge_DirectionType_DirectionType_ARRAYSIZE = Edge_DirectionType_DirectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Edge_DirectionType_descriptor();
inline const ::std::string& Edge_DirectionType_Name(Edge_DirectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Edge_DirectionType_descriptor(), value);
}
inline bool Edge_DirectionType_Parse(
    const ::std::string& name, Edge_DirectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Edge_DirectionType>(
    Edge_DirectionType_descriptor(), name, value);
}
// ===================================================================

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string lane_id = 1;
  inline bool has_lane_id() const;
  inline void clear_lane_id();
  static const int kLaneIdFieldNumber = 1;
  inline const ::std::string& lane_id() const;
  inline void set_lane_id(const ::std::string& value);
  inline void set_lane_id(const char* value);
  inline void set_lane_id(const char* value, size_t size);
  inline ::std::string* mutable_lane_id();
  inline ::std::string* release_lane_id();
  inline void set_allocated_lane_id(::std::string* lane_id);

  // optional double length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline double length() const;
  inline void set_length(double value);

  // optional double cost = 3;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 3;
  inline double cost() const;
  inline void set_cost(double value);

  // optional string road_id = 4;
  inline bool has_road_id() const;
  inline void clear_road_id();
  static const int kRoadIdFieldNumber = 4;
  inline const ::std::string& road_id() const;
  inline void set_road_id(const ::std::string& value);
  inline void set_road_id(const char* value);
  inline void set_road_id(const char* value, size_t size);
  inline ::std::string* mutable_road_id();
  inline ::std::string* release_road_id();
  inline void set_allocated_road_id(::std::string* road_id);

  // optional .trunk.hadmap.Point3D pt = 5;
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 5;
  inline const ::trunk::hadmap::Point3D& pt() const;
  inline ::trunk::hadmap::Point3D* mutable_pt();
  inline ::trunk::hadmap::Point3D* release_pt();
  inline void set_allocated_pt(::trunk::hadmap::Point3D* pt);

  // @@protoc_insertion_point(class_scope:trunk.hadmap.Node)
 private:
  inline void set_has_lane_id();
  inline void clear_has_lane_id();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_cost();
  inline void clear_has_cost();
  inline void set_has_road_id();
  inline void clear_has_road_id();
  inline void set_has_pt();
  inline void clear_has_pt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* lane_id_;
  double length_;
  double cost_;
  ::std::string* road_id_;
  ::trunk::hadmap::Point3D* pt_;
  friend void  protobuf_AddDesc_proto_2ftopo_5fgraph_2eproto();
  friend void protobuf_AssignDesc_proto_2ftopo_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_proto_2ftopo_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  void Swap(Edge* other);

  // implements Message ----------------------------------------------

  Edge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Edge_DirectionType DirectionType;
  static const DirectionType FORWARD = Edge_DirectionType_FORWARD;
  static const DirectionType LEFT = Edge_DirectionType_LEFT;
  static const DirectionType RIGHT = Edge_DirectionType_RIGHT;
  static inline bool DirectionType_IsValid(int value) {
    return Edge_DirectionType_IsValid(value);
  }
  static const DirectionType DirectionType_MIN =
    Edge_DirectionType_DirectionType_MIN;
  static const DirectionType DirectionType_MAX =
    Edge_DirectionType_DirectionType_MAX;
  static const int DirectionType_ARRAYSIZE =
    Edge_DirectionType_DirectionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DirectionType_descriptor() {
    return Edge_DirectionType_descriptor();
  }
  static inline const ::std::string& DirectionType_Name(DirectionType value) {
    return Edge_DirectionType_Name(value);
  }
  static inline bool DirectionType_Parse(const ::std::string& name,
      DirectionType* value) {
    return Edge_DirectionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string from_lane_id = 1;
  inline bool has_from_lane_id() const;
  inline void clear_from_lane_id();
  static const int kFromLaneIdFieldNumber = 1;
  inline const ::std::string& from_lane_id() const;
  inline void set_from_lane_id(const ::std::string& value);
  inline void set_from_lane_id(const char* value);
  inline void set_from_lane_id(const char* value, size_t size);
  inline ::std::string* mutable_from_lane_id();
  inline ::std::string* release_from_lane_id();
  inline void set_allocated_from_lane_id(::std::string* from_lane_id);

  // optional string to_lane_id = 2;
  inline bool has_to_lane_id() const;
  inline void clear_to_lane_id();
  static const int kToLaneIdFieldNumber = 2;
  inline const ::std::string& to_lane_id() const;
  inline void set_to_lane_id(const ::std::string& value);
  inline void set_to_lane_id(const char* value);
  inline void set_to_lane_id(const char* value, size_t size);
  inline ::std::string* mutable_to_lane_id();
  inline ::std::string* release_to_lane_id();
  inline void set_allocated_to_lane_id(::std::string* to_lane_id);

  // optional double cost = 3;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 3;
  inline double cost() const;
  inline void set_cost(double value);

  // optional .trunk.hadmap.Edge.DirectionType direction_type = 4;
  inline bool has_direction_type() const;
  inline void clear_direction_type();
  static const int kDirectionTypeFieldNumber = 4;
  inline ::trunk::hadmap::Edge_DirectionType direction_type() const;
  inline void set_direction_type(::trunk::hadmap::Edge_DirectionType value);

  // @@protoc_insertion_point(class_scope:trunk.hadmap.Edge)
 private:
  inline void set_has_from_lane_id();
  inline void clear_has_from_lane_id();
  inline void set_has_to_lane_id();
  inline void clear_has_to_lane_id();
  inline void set_has_cost();
  inline void clear_has_cost();
  inline void set_has_direction_type();
  inline void clear_has_direction_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* from_lane_id_;
  ::std::string* to_lane_id_;
  double cost_;
  int direction_type_;
  friend void  protobuf_AddDesc_proto_2ftopo_5fgraph_2eproto();
  friend void protobuf_AssignDesc_proto_2ftopo_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_proto_2ftopo_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static Edge* default_instance_;
};
// -------------------------------------------------------------------

class Graph : public ::google::protobuf::Message {
 public:
  Graph();
  virtual ~Graph();

  Graph(const Graph& from);

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Graph& default_instance();

  void Swap(Graph* other);

  // implements Message ----------------------------------------------

  Graph* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Graph& from);
  void MergeFrom(const Graph& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hadmap_version = 1;
  inline bool has_hadmap_version() const;
  inline void clear_hadmap_version();
  static const int kHadmapVersionFieldNumber = 1;
  inline const ::std::string& hadmap_version() const;
  inline void set_hadmap_version(const ::std::string& value);
  inline void set_hadmap_version(const char* value);
  inline void set_hadmap_version(const char* value, size_t size);
  inline ::std::string* mutable_hadmap_version();
  inline ::std::string* release_hadmap_version();
  inline void set_allocated_hadmap_version(::std::string* hadmap_version);

  // optional string hadmap_district = 2;
  inline bool has_hadmap_district() const;
  inline void clear_hadmap_district();
  static const int kHadmapDistrictFieldNumber = 2;
  inline const ::std::string& hadmap_district() const;
  inline void set_hadmap_district(const ::std::string& value);
  inline void set_hadmap_district(const char* value);
  inline void set_hadmap_district(const char* value, size_t size);
  inline ::std::string* mutable_hadmap_district();
  inline ::std::string* release_hadmap_district();
  inline void set_allocated_hadmap_district(::std::string* hadmap_district);

  // repeated .trunk.hadmap.Node node = 3;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 3;
  inline const ::trunk::hadmap::Node& node(int index) const;
  inline ::trunk::hadmap::Node* mutable_node(int index);
  inline ::trunk::hadmap::Node* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Node >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Node >*
      mutable_node();

  // repeated .trunk.hadmap.Edge edge = 4;
  inline int edge_size() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 4;
  inline const ::trunk::hadmap::Edge& edge(int index) const;
  inline ::trunk::hadmap::Edge* mutable_edge(int index);
  inline ::trunk::hadmap::Edge* add_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Edge >&
      edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Edge >*
      mutable_edge();

  // @@protoc_insertion_point(class_scope:trunk.hadmap.Graph)
 private:
  inline void set_has_hadmap_version();
  inline void clear_has_hadmap_version();
  inline void set_has_hadmap_district();
  inline void clear_has_hadmap_district();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hadmap_version_;
  ::std::string* hadmap_district_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Node > node_;
  ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Edge > edge_;
  friend void  protobuf_AddDesc_proto_2ftopo_5fgraph_2eproto();
  friend void protobuf_AssignDesc_proto_2ftopo_5fgraph_2eproto();
  friend void protobuf_ShutdownFile_proto_2ftopo_5fgraph_2eproto();

  void InitAsDefaultInstance();
  static Graph* default_instance_;
};
// ===================================================================


// ===================================================================

// Node

// optional string lane_id = 1;
inline bool Node::has_lane_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_lane_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_lane_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_lane_id() {
  if (lane_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lane_id_->clear();
  }
  clear_has_lane_id();
}
inline const ::std::string& Node::lane_id() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Node.lane_id)
  return *lane_id_;
}
inline void Node::set_lane_id(const ::std::string& value) {
  set_has_lane_id();
  if (lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lane_id_ = new ::std::string;
  }
  lane_id_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Node.lane_id)
}
inline void Node::set_lane_id(const char* value) {
  set_has_lane_id();
  if (lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lane_id_ = new ::std::string;
  }
  lane_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Node.lane_id)
}
inline void Node::set_lane_id(const char* value, size_t size) {
  set_has_lane_id();
  if (lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lane_id_ = new ::std::string;
  }
  lane_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Node.lane_id)
}
inline ::std::string* Node::mutable_lane_id() {
  set_has_lane_id();
  if (lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lane_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Node.lane_id)
  return lane_id_;
}
inline ::std::string* Node::release_lane_id() {
  clear_has_lane_id();
  if (lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lane_id_;
    lane_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Node::set_allocated_lane_id(::std::string* lane_id) {
  if (lane_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lane_id_;
  }
  if (lane_id) {
    set_has_lane_id();
    lane_id_ = lane_id;
  } else {
    clear_has_lane_id();
    lane_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Node.lane_id)
}

// optional double length = 2;
inline bool Node::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline double Node::length() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Node.length)
  return length_;
}
inline void Node::set_length(double value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:trunk.hadmap.Node.length)
}

// optional double cost = 3;
inline bool Node::has_cost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_cost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_cost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline double Node::cost() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Node.cost)
  return cost_;
}
inline void Node::set_cost(double value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:trunk.hadmap.Node.cost)
}

// optional string road_id = 4;
inline bool Node::has_road_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node::set_has_road_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node::clear_has_road_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node::clear_road_id() {
  if (road_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    road_id_->clear();
  }
  clear_has_road_id();
}
inline const ::std::string& Node::road_id() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Node.road_id)
  return *road_id_;
}
inline void Node::set_road_id(const ::std::string& value) {
  set_has_road_id();
  if (road_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    road_id_ = new ::std::string;
  }
  road_id_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Node.road_id)
}
inline void Node::set_road_id(const char* value) {
  set_has_road_id();
  if (road_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    road_id_ = new ::std::string;
  }
  road_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Node.road_id)
}
inline void Node::set_road_id(const char* value, size_t size) {
  set_has_road_id();
  if (road_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    road_id_ = new ::std::string;
  }
  road_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Node.road_id)
}
inline ::std::string* Node::mutable_road_id() {
  set_has_road_id();
  if (road_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    road_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Node.road_id)
  return road_id_;
}
inline ::std::string* Node::release_road_id() {
  clear_has_road_id();
  if (road_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = road_id_;
    road_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Node::set_allocated_road_id(::std::string* road_id) {
  if (road_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete road_id_;
  }
  if (road_id) {
    set_has_road_id();
    road_id_ = road_id;
  } else {
    clear_has_road_id();
    road_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Node.road_id)
}

// optional .trunk.hadmap.Point3D pt = 5;
inline bool Node::has_pt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Node::set_has_pt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Node::clear_has_pt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Node::clear_pt() {
  if (pt_ != NULL) pt_->::trunk::hadmap::Point3D::Clear();
  clear_has_pt();
}
inline const ::trunk::hadmap::Point3D& Node::pt() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Node.pt)
  return pt_ != NULL ? *pt_ : *default_instance_->pt_;
}
inline ::trunk::hadmap::Point3D* Node::mutable_pt() {
  set_has_pt();
  if (pt_ == NULL) pt_ = new ::trunk::hadmap::Point3D;
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Node.pt)
  return pt_;
}
inline ::trunk::hadmap::Point3D* Node::release_pt() {
  clear_has_pt();
  ::trunk::hadmap::Point3D* temp = pt_;
  pt_ = NULL;
  return temp;
}
inline void Node::set_allocated_pt(::trunk::hadmap::Point3D* pt) {
  delete pt_;
  pt_ = pt;
  if (pt) {
    set_has_pt();
  } else {
    clear_has_pt();
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Node.pt)
}

// -------------------------------------------------------------------

// Edge

// optional string from_lane_id = 1;
inline bool Edge::has_from_lane_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edge::set_has_from_lane_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edge::clear_has_from_lane_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edge::clear_from_lane_id() {
  if (from_lane_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_lane_id_->clear();
  }
  clear_has_from_lane_id();
}
inline const ::std::string& Edge::from_lane_id() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Edge.from_lane_id)
  return *from_lane_id_;
}
inline void Edge::set_from_lane_id(const ::std::string& value) {
  set_has_from_lane_id();
  if (from_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_lane_id_ = new ::std::string;
  }
  from_lane_id_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Edge.from_lane_id)
}
inline void Edge::set_from_lane_id(const char* value) {
  set_has_from_lane_id();
  if (from_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_lane_id_ = new ::std::string;
  }
  from_lane_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Edge.from_lane_id)
}
inline void Edge::set_from_lane_id(const char* value, size_t size) {
  set_has_from_lane_id();
  if (from_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_lane_id_ = new ::std::string;
  }
  from_lane_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Edge.from_lane_id)
}
inline ::std::string* Edge::mutable_from_lane_id() {
  set_has_from_lane_id();
  if (from_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_lane_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Edge.from_lane_id)
  return from_lane_id_;
}
inline ::std::string* Edge::release_from_lane_id() {
  clear_has_from_lane_id();
  if (from_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = from_lane_id_;
    from_lane_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Edge::set_allocated_from_lane_id(::std::string* from_lane_id) {
  if (from_lane_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_lane_id_;
  }
  if (from_lane_id) {
    set_has_from_lane_id();
    from_lane_id_ = from_lane_id;
  } else {
    clear_has_from_lane_id();
    from_lane_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Edge.from_lane_id)
}

// optional string to_lane_id = 2;
inline bool Edge::has_to_lane_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edge::set_has_to_lane_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edge::clear_has_to_lane_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edge::clear_to_lane_id() {
  if (to_lane_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_lane_id_->clear();
  }
  clear_has_to_lane_id();
}
inline const ::std::string& Edge::to_lane_id() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Edge.to_lane_id)
  return *to_lane_id_;
}
inline void Edge::set_to_lane_id(const ::std::string& value) {
  set_has_to_lane_id();
  if (to_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_lane_id_ = new ::std::string;
  }
  to_lane_id_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Edge.to_lane_id)
}
inline void Edge::set_to_lane_id(const char* value) {
  set_has_to_lane_id();
  if (to_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_lane_id_ = new ::std::string;
  }
  to_lane_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Edge.to_lane_id)
}
inline void Edge::set_to_lane_id(const char* value, size_t size) {
  set_has_to_lane_id();
  if (to_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_lane_id_ = new ::std::string;
  }
  to_lane_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Edge.to_lane_id)
}
inline ::std::string* Edge::mutable_to_lane_id() {
  set_has_to_lane_id();
  if (to_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_lane_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Edge.to_lane_id)
  return to_lane_id_;
}
inline ::std::string* Edge::release_to_lane_id() {
  clear_has_to_lane_id();
  if (to_lane_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = to_lane_id_;
    to_lane_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Edge::set_allocated_to_lane_id(::std::string* to_lane_id) {
  if (to_lane_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete to_lane_id_;
  }
  if (to_lane_id) {
    set_has_to_lane_id();
    to_lane_id_ = to_lane_id;
  } else {
    clear_has_to_lane_id();
    to_lane_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Edge.to_lane_id)
}

// optional double cost = 3;
inline bool Edge::has_cost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Edge::set_has_cost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Edge::clear_has_cost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Edge::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline double Edge::cost() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Edge.cost)
  return cost_;
}
inline void Edge::set_cost(double value) {
  set_has_cost();
  cost_ = value;
  // @@protoc_insertion_point(field_set:trunk.hadmap.Edge.cost)
}

// optional .trunk.hadmap.Edge.DirectionType direction_type = 4;
inline bool Edge::has_direction_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Edge::set_has_direction_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Edge::clear_has_direction_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Edge::clear_direction_type() {
  direction_type_ = 0;
  clear_has_direction_type();
}
inline ::trunk::hadmap::Edge_DirectionType Edge::direction_type() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Edge.direction_type)
  return static_cast< ::trunk::hadmap::Edge_DirectionType >(direction_type_);
}
inline void Edge::set_direction_type(::trunk::hadmap::Edge_DirectionType value) {
  assert(::trunk::hadmap::Edge_DirectionType_IsValid(value));
  set_has_direction_type();
  direction_type_ = value;
  // @@protoc_insertion_point(field_set:trunk.hadmap.Edge.direction_type)
}

// -------------------------------------------------------------------

// Graph

// optional string hadmap_version = 1;
inline bool Graph::has_hadmap_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Graph::set_has_hadmap_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Graph::clear_has_hadmap_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Graph::clear_hadmap_version() {
  if (hadmap_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_version_->clear();
  }
  clear_has_hadmap_version();
}
inline const ::std::string& Graph::hadmap_version() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Graph.hadmap_version)
  return *hadmap_version_;
}
inline void Graph::set_hadmap_version(const ::std::string& value) {
  set_has_hadmap_version();
  if (hadmap_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_version_ = new ::std::string;
  }
  hadmap_version_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Graph.hadmap_version)
}
inline void Graph::set_hadmap_version(const char* value) {
  set_has_hadmap_version();
  if (hadmap_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_version_ = new ::std::string;
  }
  hadmap_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Graph.hadmap_version)
}
inline void Graph::set_hadmap_version(const char* value, size_t size) {
  set_has_hadmap_version();
  if (hadmap_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_version_ = new ::std::string;
  }
  hadmap_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Graph.hadmap_version)
}
inline ::std::string* Graph::mutable_hadmap_version() {
  set_has_hadmap_version();
  if (hadmap_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Graph.hadmap_version)
  return hadmap_version_;
}
inline ::std::string* Graph::release_hadmap_version() {
  clear_has_hadmap_version();
  if (hadmap_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hadmap_version_;
    hadmap_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Graph::set_allocated_hadmap_version(::std::string* hadmap_version) {
  if (hadmap_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hadmap_version_;
  }
  if (hadmap_version) {
    set_has_hadmap_version();
    hadmap_version_ = hadmap_version;
  } else {
    clear_has_hadmap_version();
    hadmap_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Graph.hadmap_version)
}

// optional string hadmap_district = 2;
inline bool Graph::has_hadmap_district() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Graph::set_has_hadmap_district() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Graph::clear_has_hadmap_district() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Graph::clear_hadmap_district() {
  if (hadmap_district_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_district_->clear();
  }
  clear_has_hadmap_district();
}
inline const ::std::string& Graph::hadmap_district() const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Graph.hadmap_district)
  return *hadmap_district_;
}
inline void Graph::set_hadmap_district(const ::std::string& value) {
  set_has_hadmap_district();
  if (hadmap_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_district_ = new ::std::string;
  }
  hadmap_district_->assign(value);
  // @@protoc_insertion_point(field_set:trunk.hadmap.Graph.hadmap_district)
}
inline void Graph::set_hadmap_district(const char* value) {
  set_has_hadmap_district();
  if (hadmap_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_district_ = new ::std::string;
  }
  hadmap_district_->assign(value);
  // @@protoc_insertion_point(field_set_char:trunk.hadmap.Graph.hadmap_district)
}
inline void Graph::set_hadmap_district(const char* value, size_t size) {
  set_has_hadmap_district();
  if (hadmap_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_district_ = new ::std::string;
  }
  hadmap_district_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trunk.hadmap.Graph.hadmap_district)
}
inline ::std::string* Graph::mutable_hadmap_district() {
  set_has_hadmap_district();
  if (hadmap_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hadmap_district_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Graph.hadmap_district)
  return hadmap_district_;
}
inline ::std::string* Graph::release_hadmap_district() {
  clear_has_hadmap_district();
  if (hadmap_district_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hadmap_district_;
    hadmap_district_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Graph::set_allocated_hadmap_district(::std::string* hadmap_district) {
  if (hadmap_district_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hadmap_district_;
  }
  if (hadmap_district) {
    set_has_hadmap_district();
    hadmap_district_ = hadmap_district;
  } else {
    clear_has_hadmap_district();
    hadmap_district_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trunk.hadmap.Graph.hadmap_district)
}

// repeated .trunk.hadmap.Node node = 3;
inline int Graph::node_size() const {
  return node_.size();
}
inline void Graph::clear_node() {
  node_.Clear();
}
inline const ::trunk::hadmap::Node& Graph::node(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Graph.node)
  return node_.Get(index);
}
inline ::trunk::hadmap::Node* Graph::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Graph.node)
  return node_.Mutable(index);
}
inline ::trunk::hadmap::Node* Graph::add_node() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Graph.node)
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Node >&
Graph::node() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Graph.node)
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Node >*
Graph::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Graph.node)
  return &node_;
}

// repeated .trunk.hadmap.Edge edge = 4;
inline int Graph::edge_size() const {
  return edge_.size();
}
inline void Graph::clear_edge() {
  edge_.Clear();
}
inline const ::trunk::hadmap::Edge& Graph::edge(int index) const {
  // @@protoc_insertion_point(field_get:trunk.hadmap.Graph.edge)
  return edge_.Get(index);
}
inline ::trunk::hadmap::Edge* Graph::mutable_edge(int index) {
  // @@protoc_insertion_point(field_mutable:trunk.hadmap.Graph.edge)
  return edge_.Mutable(index);
}
inline ::trunk::hadmap::Edge* Graph::add_edge() {
  // @@protoc_insertion_point(field_add:trunk.hadmap.Graph.edge)
  return edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Edge >&
Graph::edge() const {
  // @@protoc_insertion_point(field_list:trunk.hadmap.Graph.edge)
  return edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::trunk::hadmap::Edge >*
Graph::mutable_edge() {
  // @@protoc_insertion_point(field_mutable_list:trunk.hadmap.Graph.edge)
  return &edge_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace hadmap
}  // namespace trunk

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::trunk::hadmap::Edge_DirectionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trunk::hadmap::Edge_DirectionType>() {
  return ::trunk::hadmap::Edge_DirectionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2ftopo_5fgraph_2eproto__INCLUDED
